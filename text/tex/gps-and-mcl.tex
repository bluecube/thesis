\chapter{GPS and Monte Carlo Localization}
\label{chap:gps-and-mcl}

This chapter discusses using GPS data as an input to to Monte Carlo localization,
concentrating on problems common to all GPS receivers.
Specific problems and implementation decisions encountered with the SiRF receiver
during the implementation part are addressed in \cref{chap:implementation}.

As discussed in \cref{chap:mcl}, Monte Carlo localization accepts two kinds of
inputs -- prediction and correction.
Of these two we will consider only correction inputs as GPS doesn't provide any
a priori data about motion of the robot.

First we will concentrate on the approach based on high level data that are available
from the standard WGS84 protocol,
second we will use individual pseudorange measurements each as an independent
correction input to MCL.

\section{Position Domain Integration}
Integrating the measurements in position domain means processing the complete
fixes in ECEF reference frames (or WGS84 converted to ECEF, see \cref{sec:ref-frames})
and treating the GPS receiver as a source of absolute position and velocity information.

This approach has the advantage of being very simple, because most of the work
is done in the dedicated hardware of the GPS receiver.
On the other hand information are discarded when the fix is converted to the simple
latitude / longitude / HDOP format, which may decrease the accuracy of the
localization.
Also consumer-grade GPS receivers often employ filters tuned to specific properties
of the platform intended to carry the unit for example ignoring speeds
below a certain threshold or limiting allowed accelerations.

It would also be possible for position domain integration to utilize speed information
from the GPS (NMEA message GPRMC contains velocity in knots and track angle \cite{depriest}).
For this work, however, we choose not to utilize it, to avoid the complexity of converting
track course and speed to reference frames usable for robot navigation.

\subsection{Robot State}
For position domain integration we work in a two dimensional coordinate
system on a surface of Earth, with X axis going East and Y axis going North.
WGS84 inputs are transformed to this reference frame using orthogonal projection
this reported position and HDOP are used to modify weights of the samples.
Details of this can be found in \cref{sec:impl-coordinates}.

No other variables are required in the robot's state for this method.
This makes it possible to seamlessly integrate it into existing localization framework.
Adding another more state, however might improve the accuracy, one such option
is discussed in \cref{sec:position-domain-correlation}.

\subsection{Sensor Model}
\label{sec:wgs84-hdop-error}

\begin{figure}[htp]
	\centering
	\noindent\makebox[\textwidth]{
	\includegraphics{generated/wgs84-hdop-error.pdf}
	}
	\caption{Measurement errors vs. HDOP.}
	\label{fig:wgs84-hdop-error}
\end{figure}

Because position domain integration as used here has no persistent variables in the
robot state, it does not need any operations during the prediction step of MCL.
Our error model for correction step for the correction phase follows \cite{www-wilson}.

In this case we are operating only in two dimensions.
The horizontal component of the position error  \(\vect{\delta R}\) is modelled using Rayleigh distribution
parameterized with HDOP of the measurement:
\begin{equation}
	\Prob(\norm{\vect{\delta R}} < x \mid \HDOP) =
		1 - e^{-x^2/2\sigma(\HDOP)^2}
\end{equation}

Parameter \(\sigma(\HDOP)\) of the distribution is chosen to fit the DRMS values using a maximum likehood estimate
\begin{equation}
	\sigma(\HDOP) = \frac{\mathrm{DRMS}(\HDOP)}{\sqrt{2}}
\end{equation}

Experimentally measured data were fitted to the theoretical linear model and to
the non-linear model from \cite{www-wilson}.
Both were fitted to the data using least squares weighted with counts of samples
for each HDOP, resulting in the expressions
\begin{equation}
\mathrm{DRMS}(\HDOP) = \num{6.255} \HDOP
\end{equation}
and
\begin{equation}
\mathrm{DRMS}(\HDOP) = \sqrt{(\num{4.941}\HDOP)^2 + \num{3.568}^2}
\end{equation}

\Cref{fig:wgs84-hdop-error} is a visualisation of fitting of these two models,
blue dots representing the measured data, yellow dots the DRMS values.
Green line shows the theoretical linear model and red curve is the non linear model.
Limited resolution of the HDOP values in input data is visible in the plot.
This figure also shows precision available when using simple NMEA data --
position error of roughly \SI{10}{\meter} with most of the measuremnts.
Another interesting fact is to note, that only relatively low HDOP values were encountered.
\Cref{fig:hdop-hist} shows this in a more pronounced way.

To obtain the final sensor model, we must express the PDF of Rayleight distribution:
\begin{equation}
    f(x) = \frac{x}{\sigma^2}e^{-x^2/2\sigma^2}
\end{equation}

\Cref{algo:gps-position-domain} shows a pseudo code implementation of a function
that provides a sensor model to MCL algorithm from \cref{chap:mcl} based on the
fitted non-linear model.

\begin{figure}[tp]
\begin{algorithm}[H]
    \SetKwFunction{project}{project}
    \SetKwFunction{abs}{abs}
    \SetKwFunction{exp}{exp}

    \SetKwData{sample}{sample}
    \SetKwData{projected}{projected}
    \SetKwData{observation}{observation}
    \SetKwData{hdop}{HDOP}
    \SetKwData{latLon}{latLon}
    \SetKwData{pos}{position}
    \SetKwData{positionError}{positionError}
    \SetKwData{drms}{DRMS}
    \SetKwData{drmsSquared}{\(\drms^2\)}

    \function{observationProbabilityGPS}{
        \KwIn{sample, observation}
        \KwOut{probability}
        \BlankLine
        \projected \assign \project{\observation.\latLon}\;
        \hdop \assign \observation.\hdop\;
        \BlankLine
        \positionError \assign \abs{\projected \(-\) \sample}\;
        \drmsSquared \assign \( ( \num{4.941}\hdop )^2 + \num{3.568}^2 \)\;% (\num{4.941}\HDOP)^2 + \num{3.568}^2 )\;
        \BlankLine
        \Return 2 * \positionError / \drmsSquared * \exp{-\(\positionError^2\)/\drmsSquared} \;
    }
\end{algorithm}
\caption{Correction algorithm for position domain integration of GPS measurements}
\label{algo:gps-position-domain}
\end{figure}

\subsection{Correlation of Position Errors}
\label{sec:position-domain-correlation}
A problem that is hard to avoid with this approach is that position errors of the
receiver output are correlated.
This is in part because errors of the individual satellite measurements are correlated
(which is discussed in \cref{sec:measurement-domain-correlation}), but another major reason
is the \enquote{inertia} added by the Kalman filter.
This kind of correlation obviously breaks the independence assumptions of Markov
localization defined in \cref{sec:markov-assumptions}.

An attempt at mitigating this could be done by estimating the error as part of
the robot's state, possibly removing atmospheric effects and some of the low pass
filtering properties of the Kalman filter in the receiver.
These options, however, will not be explored in this work.

\section{Measurement Domain Integration}
\label{sec:measurement-domain}

Measurement domain integration takes each pseudorange measurement as an input
and combines it with other sensor data.

In Monte Carlo localization GPS data are used in a similar way as
for example ultrasound ranging beacons would be used,
taking each measured pseudorange after a correction for measurement errors
and after clock correction modifying the sample weight based on the measured distance
compared to expected distance.
GPS, of cause has the additional complexity of the receiver clock offset, which
has to be known in order to transform pseudoranges to measured geometric ranges.

The main reason for attempting to use the GPS in this way is to add more information
into the localization process and to have more control over assumptions made during
processing of the GPS data.

To improve accuracy, we also track residual errors for each individual satellite.
Main cause for these errors are in ionosphere, but this treatment should be also
capable of alleviating other errors that change slowly over time, like satellite
clock offsets.

\subsection{Static Environment Assumption}
\label{sec:gps-mcl-static-env}
Monte Carlo Localization assumes that the environment is static, but we need to
localize according to moving satellites.
To avoid this problem we will hide satellite motion into the robot state and sensor model.

\subsection{Robot State}
Unlike the position domain integration approach, this method requires specific
way of storing the position and velocity of the robot and
additional data in the robot state in MCL samples.

First of all, the whole GPS operations work in ECEF coordinate system, meaning
that the robot position and velocity also must be stored in this coordinate system.
Next, the GPS needs to estimate a receiver clock offset as a position together
with position, so this is another variable which must exist in the state.

The state variables will also have to contain velocities in ECEF and clock drift.

We also estimate residual errors of each satellite,
consisting of residual clock offset and residual clock drift.
These residual clock offsets cover all of the slowly changing errors that are present
in each satellite's transmission and are not explicitly corrected elsewhere in the process.
This includes satellite clock inaccuracies, unmodeled remains of ionospheric and
tropospheric errors and to some extent also satellite ephemeris errors.

\subsection{Sensor Model}

\subsubsection{Preprocessing}
Preprocessing steps of the data stream is receiver specific,
and discussed in \cref{sec:impl-sirf-grouping,sec:impl-sirf-jumps,sec:impl-sirf-ephemeris}.
In short, this consists of integrating ephemeris, removing any inconsistencies in data caused by the
receiver and converting the data to sequences of pseudoranges and Doppler measurements.

\subsubsection{Clock Offsets and Drifts}
Clock offse


The only preprocessing step, these values are thresholded, discarding measurements that are too
far from the expected position.
\SI{150}{\meter} for pseudoranges and \SI{4}{\meter\per\second} for doppler velocity
measurements.


\subsubsection{Error distribution}
Normal distribution (???)

\subsubsection{Algorithm}

\begin{figure}[tp]
\begin{algorithm}[H]
    \SetKwFunction{abs}{abs}
    \SetKwFunction{exp}{exp}
    \SetKwFunction{dotProduct}{dotProduct}
    \SetKwFunction{norm}{norm}
    \SetKwFunction{normpdf}{normpdf}
    \SetKwFunction{tropoDelay}{tropoDelay}
    \SetKwFunction{ionoDelay}{ionoDelay}

    \SetKwData{samples}{samples}
    \SetKwData{sample}{s}
    \SetKwData{samplex}{sample}


    \SetKwData{clockDrift}{clockDrift}
    \SetKwData{clockOffset}{clockOffset}
    \SetKwArray{residualDrift}{residualDrift}
    \SetKwArray{residualOffset}{residualOffset}
    \SetKwData{sv}{sv}
    \SetKwData{svs}{svList}
    \SetKwData{geometricDistance}{geometricDistance}
    \SetKwData{pseudorange}{pseudorange}
    \SetKwData{position}{position}
    \SetKwData{velocity}{velocity}
    \SetKwData{relativeVelocity}{relativeVelocity}
    \SetKwData{userToSv}{userToSv}
    \SetKwData{geomRange}{geomRange}
    \SetKwData{geomVelocity}{geomVelocity}
    \SetKwData{pseudorangeError}{pseudorangeError}
    \SetKwData{velocityError}{velocityError}
    \SetKwData{observation}{observation}
    %\SetKwData{x}{x}
    %\SetKwData{x}{x}

    \function{predictGPS}{
        \KwIn{list of samples}
        \KwOut{modified list of samples}
        \BlankLine
        \ForEach{\sample \(\in\) \samples}{
            \sample.\clockDrift \assign \sample.\clockDrift \(+\) \norm{\(\mu\) = \num{-0.0145}, \(\sigma\) = \num{8.0331}}\;
            \sample.\clockOffset \assign \sample.\clockOffset \(+\) \sample.\clockDrift\;

            \BlankLine
            \ForEach{\sv \(\in\) \svs}{
                \sample.\residualDrift{\sv} \assign \sample.\residualDrift{\sv} \(+\) \norm{\(\mu\) = \num{-0.0145}, \(\sigma\) = \num{8.0331}}\;
                \sample.\residualOffset{\sv} \assign \sample.\residualOffset{\sv} \(+\) \sample.\residualDrift{\sv}\;
            }
        }
        \BlankLine
        \Return{\samples}\;
    }

    \BlankLine
    \BlankLine
    \BlankLine
    \function{observationProbabilityGPS}{
        \KwIn{sample, observation}
        \KwOut{probability}

        \BlankLine
        \sv \assign \observation.\sv\;
        \clockDrift = \samplex.\clockDrift + \samplex.\residualDrift{\sv}\;
        \clockOffset = \samplex.\clockOffset + \samplex.\residualOffset{\sv}\;

        \BlankLine
        \pseudorange \assign \samplex.\pseudorange\\
            \hspace{1em} \(+\) \(\speedoflight\) \(*\) \sv.\clockOffset\\
            \hspace{1em} \(-\) \(\speedoflight\) \(*\) \clockOffset\\
            \hspace{1em} \(-\) \ionoDelay{\sv, \samplex}\\
            \hspace{1em} \(-\) \tropoDelay{\sv, \samplex}\;
        \velocity \assign \samplex.\velocity\\
            \hspace{1em} \(+\) \(\speedoflight\) \(*\) \sv.\clockDrift\\
            \hspace{1em} \(-\) \(\speedoflight\) \(*\) \clockDrift\;

        \BlankLine
        \userToSv \assign \sv.\position \(-\) \samplex.\position\;
        \relativeVelocity \assign \sv.\velocity \(-\) \samplex.\velocity\;

        \geomRange \assign \abs{\userToSv}\;
        \geomVelocity \assign \dotProduct{\relativeVelocity, \userToSv} / \geomRange\;

        \BlankLine
        \Return  \normpdf{\pseudorange \(-\) \geomRange, \(\mu\) = \num{-0.0145}, \(\sigma\) = \num{8.0331}} * \\
             \hspace{1em} \normpdf{\velocity \(-\) \geomVelocity, \(\mu\) = \num{-0.4588}, \(\sigma\) = \num{1.1618}}\;
    }
\end{algorithm}
\caption{Prediction and correction algorithms for measurement domain integration of GPS measurements}
\label{algo:gps-measurement-domain}
\end{figure}



\subsection{Initial estimate}
\begin{itemize}
\item starting as position domain, later switching to measurement domain
\end{itemize}

\subsection{Simplifications}
\begin{itemize}
\item Ignoring altitude (???)
\item Additional 1D kalman for altitude (???)
\item Additional 1D kalman for receiver clock error (???)
\end{itemize}
