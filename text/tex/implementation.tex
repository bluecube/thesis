\chapter{Implementation}
\label{chap:implementation}

A proof of concept implementation of both approaches from \cref{chap:gps-and-mcl}
was created with this work.
The following chapter describes this implementation, its design and
specifics of the GPS receiver used.
Detailed usage information for the tools described in this chapter are located in
\cref{chap:usage}.

Python programming language was chosen for the implementation,
because of the speed of development and large number of available libraries.
As mentioned above, it is intended only as a proof of
concept and for further experimenting; a \enquote{real world} implementation
would probably be written in C or C++, for increased performance and better portability
to embedded systems, using libraries like GPSTk \cite{tolman04} for the low level GPS access.

\section{Design}
\begin{itemize}
\item Record / replay
\end{itemize}

\section{What's specific to SiRF}
\label{sec:impl-sirf}
\begin{itemize}
\item All measurements normalized to common time
\item Relativistic errors are already taken care of
\item SV positions given in ECEF, instead of orbit parameters
\item \ldots
\end{itemize}

\subsection{Communication With SiRF Chip}
\begin{itemize}
\item Detection / switching: SiRF binary <-> NMEA
\item Parsing and building SiRF messages
\end{itemize}

\section{Position Domain Error Model}

\subsection{Mapping Coordinate Frames}
\label{sec:impl-coordinates}


\section{Measurement Domain Error Model}

In contrast to the previous approach, the whole localization process is kept in
the ECEF coordinate frame, because GPS of the amount of GPS data being processed.

