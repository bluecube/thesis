\chapter{Implementation}
\label{chap:implementation}

A proof of concept implementation of both approaches from \cref{chap:gps-and-mcl}
was created with this work.
The following chapter describes this implementation, its design and
specifics of the GPS receiver used.
Detailed usage information for the tools described in this chapter are located in
\cref{chap:usage}.

Python programming language was chosen for the implementation,
because of the speed of development and large number of available libraries.
As mentioned above, it is intended only as a proof of
concept and for further experimenting; a \enquote{real world} implementation
would probably be written in C or C++, for increased performance and better portability
to embedded systems, using libraries like GPSTk \cite{tolman04} for the low level GPS access.

\section{Design}
\begin{itemize}
\item Record / replay
\end{itemize}

\section{Specifics to SiRF Chipset}
\label{sec:impl-sirf}

\begin{itemize}
\item Pseudorange does not contain ionospheric, tropospheric or clock corrections
\end{itemize}

Unlike the WGS84 position / velocity data that can be retrieved from the GPS receiver in a standard
NMEA protocol, pseudoranges and other lower level details must be obtained
in a receiver specific manner.

Implementation part of this thesis was performed with a GPS receiver containing
a SiRF III chipset, and the following sections describe specifics of working with
this hardware.

SiRF III is a fairly high quality consumer receiver found in many
\enquote{black boxes} on the market.
Apart from the standard NMEA, it can be switched to a proprietary binary protocol
which provides access to much more of the chip's features.
There is a single publicly available piece of documentation concerning this
interface \cite{sirf-protocol}, but details about workings of the chip are hard
to find and must be pieced together from forum posts (especially the thread
\cite{gpspassion-sirf} at gpspassion forums) and trial and error.


\begin{itemize}
\item Relativistic errors are already taken care of \todo{Really?}
\item SV positions given in ECEF, instead of orbit parameters
\item Carrier phases are not reported, but are used to smooth pseudorange measurements
    This sucks.
\item \ldots
\end{itemize}

\subsection{Communication With SiRF Chip}
\begin{itemize}
\item Detection / switching: SiRF binary <-> NMEA
\item Parsing and building SiRF messages
\end{itemize}

\subsection{Grouping of Reported Measurements}
All measurements reported by the chipset are grouped and appear
to have to have been made simultaneously.
Reportedly this is to simplify single point solving of the GPS position.

In later text we will refer to these measurements as groups and use average
measurement error of the group in several calculations.

\subsection{Clock Jumps in SiRF Output}
SiRF III chipset appears to internally modify its clock when the clock offset
becomes too large.
This causes problems when processing the raw data, because reported clock values
can't be relied on being monotonic.
Example of this is shown in \cref{fig:impl-clock-jumps}.

We work around this problem by measure difference between consecutive average
measurement errors and when it becomes very large (larger than \SI{1e6}{\meter} proves as an
appropriate value) we mark this measurement as a skip and estimate the skip
length to match the difference between previous pair of average errors.

\begin{figure}[tp]
	\centering
	\missingfigure{Example of clock jumps in SiRF output data}
	\caption{Example of clock jumps in SiRF output data}
	\label{fig:impl-clock-jumps}
\end{figure}

\section{Position Domain Error Model}
\begin{itemize}
\item Fixed receiver position (\cref{sec:usage-average-position-py})
\end{itemize}

\subsection{Mapping Coordinate Frames}
\label{sec:impl-coordinates}

\section{Measurement Domain Error Model}
\begin{itemize}
\item Fixed receiver position (\cref{sec:usage-average-position-py})
\item Receiver clock offset cannot be fixed (obviously)
    \begin{itemize}
    \item Assume that satellites are all around receiver
    \item -> clock offset + noise can be obtained from average pseudorange - geometric distance
    \item on clock offsets from previous steps we perform least squares in a sliding window
        (\cref{fig:sliding-window-linear-regression}).
    \end{itemize}
\end{itemize}

\begin{figure}[h]
	\centering
	\input{img/sliding-window-linear-regression.pdf_tex}
	\caption{Sliding window linear regression.}
	\label{fig:sliding-window-linear-regression}
\end{figure}


In contrast to the previous approach, the whole localization process is kept in
the ECEF coordinate frame, because GPS of the amount of GPS data being processed.

