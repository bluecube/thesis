\chapter{Implementation}
\label{chap:implementation}

A proof of concept implementation of both approaches from \cref{chap:gps-and-mcl}
was created with this work.
The following chapter describes this implementation, its design and
specifics of the GPS receiver used.
Detailed usage information for the tools described in this chapter are located in
\cref{chap:usage}.

Python programming language was chosen for the implementation,
because of the speed of development and large number of available libraries.
As mentioned above, it is intended only as a proof of
concept and for further experimenting; a \enquote{real world} implementation
would probably be written in C or C++, for increased performance and better portability
to embedded systems, using libraries like GPSTk \cite{tolman04} for the low level GPS access.

\section{Design}
\begin{itemize}
\item Record / replay
\end{itemize}

\section{Specifics to SiRF Chipset}
\label{sec:impl-sirf}

\begin{itemize}
\item Pseudorange does not contain ionospheric, tropospheric or clock corrections
\end{itemize}

Unlike the WGS84 position / velocity data that can be retrieved from the GPS receiver in a standard
NMEA protocol, pseudoranges and other lower level details must be obtained
in a receiver specific manner.

Implementation part of this thesis was performed with a GPS receiver containing
a SiRF III chipset, and the following sections describe specifics of working with
this hardware.

SiRF III is a fairly high quality consumer receiver found in many
\enquote{black boxes} on the market.
Apart from the standard NMEA, it can be switched to a proprietary binary protocol
which provides access to much more of the chip's features.
There is a single publicly available piece of documentation concerning this
interface \cite{sirf-protocol}, but details about workings of the chip are hard
to find and must be pieced together from forum posts (especially the thread
\cite{gpspassion-sirf} at gpspassion forums) and trial and error.


\begin{itemize}
\item Relativistic errors are already taken care of \todo{Really?}
\item SV positions given in ECEF, instead of orbit parameters
\item Carrier phases are not reported, but are used to smooth pseudorange measurements
    This sucks.
\item \ldots
\end{itemize}

\subsection{Communication With SiRF Chip}
\begin{itemize}
\item Detection / switching: SiRF binary <-> NMEA
\item Parsing and building SiRF messages
\end{itemize}

\subsection{Grouping of Reported Measurements}
All measurements reported by the chipset are grouped and appear
to have to have been made simultaneously.
Reportedly this is to simplify single point solving of the GPS position.

In later text we will refer to these measurements as groups and use average
measurement error of the group in several calculations.

\subsection{Clock Jumps in SiRF Output}
SiRF III chipset appears to internally modify its clock when the clock offset
becomes too large.
This causes problems when processing the raw data, because reported clock values
can't be relied on being monotonic.
Example of this is shown in \cref{fig:impl-clock-jumps}.

We work around this problem by measure difference between consecutive average
measurement errors and when it becomes very large (larger than \SI{1e6}{\meter} proves as an
appropriate value) we mark this measurement as a skip and estimate the skip
length to match the difference between previous pair of average errors.

\begin{figure}[tp]
	\centering
	\missingfigure{Example of clock jumps in SiRF output data}
	\caption{Example of clock jumps in SiRF output data}
	\label{fig:impl-clock-jumps}
\end{figure}

\section{Position Domain Error Model}
Calculating error model in position domain is done in a fairly straightforward way.
The obtained WGS84 coordinates projected onto a two dimensional plane
(details are discussed later).
The fix data are not obtained from a NMEA model, but from message 41 in SiRF
binary protocol.
This lets us simply work with both WGS84 and pseudorange on the same recording,
while keeping the available values identical to what's found in NMEA protocol.

Next, because the receiver was stationary during the whole recording, we want to
calculate the ground truth position.
To do this we assume that the reported point positions are unbiased.
This is reasonable assumption for long recordings,
because the distribution of satellites in view during a longer period is
virtually uniform which makes any potential biases in pseudorange measurements
cancel out.
This means we can obtain approximation of the real receiver position as a simple
mean of reported GPS positions.
Then for each measurement a distance from the mean position is calculated and
curves for each model are fitted.

\subsection{Mapping Coordinate Frames}
\label{sec:impl-coordinates}
Conversion between WGS84 latitude and longitude and two dimensional euclidean
plane necessary for localization is done using orthographic projection from
the library PyProj \cite{www-pyproj}.

The exact choice of projection is not that important for robots operating within
a radius of a few kilometers, but orthographic projection was chosen because
it's principle is simple to imagine.

\section{Measurement Domain Error Model}
\begin{itemize}
\item Fixed receiver position (\cref{sec:usage-average-position-py})
\item Receiver clock offset cannot be fixed (obviously)
    \begin{itemize}
    \item Assume that satellites are all around receiver
    \item -> clock offset + noise can be obtained from average pseudorange - geometric distance
    \item on clock offsets from previous steps we perform least squares in a sliding window
        (\cref{fig:sliding-window-linear-regression}).
    \end{itemize}
\end{itemize}

\begin{figure}[h]
	\centering
	\input{img/sliding-window-linear-regression.pdf_tex}
	\caption{Sliding window linear regression.}
	\label{fig:sliding-window-linear-regression}
\end{figure}


In contrast to the previous approach, the whole localization process is kept in
the ECEF coordinate frame, because GPS of the amount of GPS data being processed.

