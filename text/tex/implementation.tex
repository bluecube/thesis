\chapter{Implementation}
\label{chap:implementation}

A proof of concept implementation of both approaches from \cref{chap:gps-and-mcl}
was created with this work.
The following chapter describes this implementation, its design and
specifics of the GPS receiver used.
Detailed usage information for the tools described in this chapter are located in
\cref{chap:usage}.

\section{SiRF III}
\label{sec:impl-sirf}

Unlike the WGS84 position / velocity data that can be retrieved from the GPS receiver in a standard
NMEA protocol, pseudoranges and other lower level details must be obtained
in a receiver specific manner.

All experiments were performed with a GPS receiver containing
a SiRF III chip set, and the following sections describe specifics of working with
this hardware.
SiRF III is a fairly high quality consumer receiver found in many
\enquote{black boxes} on the market.
Apart from the standard NMEA, it can be switched to a proprietary binary protocol
which provides access to much more of the chip's features.

There is a single publicly available piece of documentation concerning this
interface \cite{sirf-protocol}, but details about workings of the chip are hard
to find and must be pieced together from forum posts (especially the thread
\cite{gpspassion-sirf} at GpsPasSion forums) and trial and error.

\subsection{Pseudorange Measurements}
\begin{itemize}
\item Pseudorange does not contain ionospheric, tropospheric or clock corrections
\item Relativistic errors are already taken care of \todo{Really?}
\item SV positions given in ECEF, instead of orbit parameters (Doesn't really belong here)
\item Carrier phases are not reported, but are used to smooth pseudorange measurements
    This sucks.
\item \ldots
\end{itemize}

\subsection{Grouping of Reported Measurements}
\label{sec:impl-sirf-grouping}
All measurements reported by the chipset are grouped and appear
to have to have been made simultaneously.
Reportedly this is to simplify single point solving of the GPS position.

In later text we will refer to these measurements as groups and use average
measurement error of the group in several calculations.

\subsection{Ephemeris}
\label{sec:impl-sirf-ephemeris}
\todo{!!!}

\subsection{Clock Jumps in SiRF Output}
\label{sec:impl-sirf-jumps}
According to \cite{sirf-protocol}, notes for message ID 28, SiRF chipset has a
notion of nominal clock drift with corresponding velocity correction of \SI{18315.766}{\meter\per\second}.
This causes the clock offset to consistently increase in time.
When it becomes too large, the chip produces a skip in its reported time and
partially corrects the offset.
In the recorded data this happens approximately every \SI{20}{\minute} and causes
problems when processing the raw data, because reported clock values
can't be relied on being monotonic.
Example of this is shown in \cref{fig:impl-clock-jumps}.

We work around this problem by measure difference between consecutive average
measurement errors and when it becomes very large (larger than \SI{1e6}{\meter} proves as an
appropriate value) we mark this measurement as a skip and estimate the skip
length to match the difference between previous pair of average errors.

\begin{figure}[tp]
	\centering
	\missingfigure{Example of clock jumps in SiRF output data}
	\caption{Example of clock jumps in SiRF output data}
	\label{fig:impl-clock-jumps}
\end{figure}

\section{Design}
Python programming language was chosen for the implementation,
because of the speed of development and large number of available libraries.
As mentioned above, it is intended only as a proof of
concept and for further experimenting and it does have performance problems
when running on batch data; a \enquote{real world} implementation
would probably be written in C or C++, for increased performance and better portability
to embedded systems, using libraries like GPSTk \cite{tolman04} for the low level GPS access.

Program created for this thesis is designed as a set of python packages and
several executable scripts.
Detailed description of these parts can be found in \cref{chap:usage},
but the general idea is, to record all data advance and later processed these
recordings.
Each of the scripts processes the recorded data in some way of values and
outputs calculated values and graphs seen through this text.

For running the python code, python 2.7 is required.
The following packages are used outside the standard library:
\begin{compactitem}
\item matplotlib
\item numpy and scipy
\item progressbar
\item pyproj
\item pyserial is required only if interfacing with a real
    GPS receiver is intended. It is not necessary for working only with recordings.
\end{compactitem}

\subsection{Communication With SiRF Chip}
The most basic function of the \verb=GPS= package is serial with the
SiRF chip.

\subsubsection{Serial Communication and Protocol Detection}
Operations with serial port are performed by the pySerial library.
Because the chip can work in several modes of communication, it is necessary to
switch it to a known one before use, this is done by attempting to read messages
from the GPS in two expected modes (4800 8N1 NMEA protocol and 115200 8N1 SiRF
binary protocol). If neither of these fits, trying all other possible
combinations of baud rate and protocol are tried.

Once the GPS mode is detected, it is switched to 115200 8N1 SiRF binary.
The rest of operations with GPS are performed in this mode.
NMEA messages can be parsed, but only the ones necessary for switching to
SiRF binary protocol are implemented.

\subsubsection{Processing the Protocol}
Messages of the SiRF binary protocol are parsed from the input stream and
representing objects are created based on classes in the file \verb=gps/sirf_messages.py=.
The message parsing code uses introspection in python to enumerate message types
available for parsing.

\subsection{Recordings}
Recordings of GPS messages are stored in a custom format containing sequence
of timestamped binary SiRF messages, the whole stream compressed with gzip.
A custom file format was chosen instead of one directly available in python,
because it allows us to store data incrementally, without keeping all of the
messages in memory.
Even though parsing of the protocol is faster than when this was attempted
using standard pickle file format, it is still optimized for simplicity
and admittedly creates a performance bottleneck.

Replaying is intended to be seamlessly interchangeable with a real GPS device,
which proved to be very useful in the early phases of experimentation.

To save time on higher level experiments, some of them (for example all \verb=errors-*.py=)
use pre-calculated data saved in numpy data dump format.
Data in this format don't have to be parsed on every load and also some basic
preprocessing steps are avoided.
The preprocessed data files are created using scripts \verb=wgs84_fixes_to_numpy.py=
for WGS84 positions of fixes and \verb=clock_offsets_to_numpy.py= for pseudorange
and velocity data.

\subsection{Interfaces to GPS Data}
There are several levels of access to the data from GPS or replay are available,
ranging from returning individual binary strings of unparsed data to an option based
on observers that are notified every time a desired type of message is encountered.

\subsection{Ephemeris}
Since SiRF III sends complete calculated positions of satellites in its binary
protocol, we are using these, although it is possible relatively easily to switch
to a different ephemeris source.
Apart from that a currently unused (and largely untested) scraper for precise
ephemeris data from the IGS service \cite{orbit-data} is implemented.

Both of these are based on the previously mentioned observer framework for processing
received GPS messages.

\section{Position Domain Error Model}
Calculating error model in position domain is done in a fairly straightforward way.
The obtained WGS84 coordinates projected onto a two dimensional plane
(details are discussed later).
The fix data are not obtained from a NMEA model, but from message 41 in SiRF
binary protocol.
This lets us simply work with both WGS84 and pseudorange on the same recording,
while keeping the available values identical to what's found in NMEA protocol.

Next, because the receiver was stationary during the whole recording, we want to
calculate the ground truth position.
To do this we assume that the reported point positions have mean in the real receiver position.
This is reasonable assumption for long recordings,
because the distribution of satellites in view during a longer period is
virtually uniform which makes any potential biases in pseudorange measurements
cancel out.
This means we can obtain approximation of the real receiver position as a simple
mean of reported GPS positions.
Then for each measurement a distance from the mean position is calculated and
curves for each model are fitted.

\subsection{Mapping Coordinate Frames}
\label{sec:impl-coordinates}
Conversion between WGS84 latitude and longitude and two dimensional euclidean
plane necessary for localization is done using orthographic projection from
the library PyProj \cite{www-pyproj}.

The exact choice of projection is not that important for robots operating within
a radius of a few kilometers, but orthographic projection was chosen because
it's principle is simple to imagine.

\section{Measurement Domain Error Model}
The basic idea for determining error model for pseudorange measurements is
similar to how error model for position domain is determined, but a complicated
by several aspects of the pseudoranges.

In contrast with the previous approach, the whole localization process is kept in
the ECEF coordinate frame, because GPS of the amount of GPS data being processed.

The main problem is determining receiver position from which the errors will be
calculated.
Spatial position can be determined fairly simply, since SiRF receiver also
reports position in ECEF reference frame and averaging these values gives
reasonable estimate, for the same reasons as averaging could have been used in
position domain integration.

\subsection{Clock Offset Estimation}
Clock offset of the receiver, on the other hand, is not fixed during the recording
and has to be estimated during the calculation.
Because we know geometric component of each pseudorange measurement, we can
calculate the receiver clock offset under the condition that there is no measurement
error.

The previous step gives us a large number of points, one for each pseudorange
measurement, with time and the idealized receiver clock offset.
It is now necessary to merge all the clock offsets to obtain clock offset for
each measurement time.

First approach explored in this thesis was to fit a polynomial through these
points, but it didn't fit the points well enough.
Currently we fit a linear function to points from a sliding window centered
around each of points as seen on \cref{fig:sliding-window-linear-regression}.

An input of this procedure is a set of points \(\{x_i, y_i\}\), marking 
time and potential clock offset of individual measurements.
For each \(i\) we select points \(P_i = \{(x_j, y_j) : \lvert{}x_j - x_i\rvert < \frac{w}{2}\}\), where
\(w\) is a width of the sliding window.
The coefficients \(a_i\) and \(b_i\) of linear functions
\(a_i (x - x_i) + b_i\) fitted through the points \(P_i\) using least squares
are used as a clock drift and clock offset of the dataset.
This calculation can be performed in \(\mathcal{O}(n)\) time, which is very
important for the sizes of datasets we deal with in this work.


\begin{figure}[h]
	\centering
	\input{img/sliding-window-linear-regression.pdf_tex}
	\caption{Sliding window linear regression.}
	\label{fig:sliding-window-linear-regression}
\end{figure}

The clock offset fitting step is done twice in our code, first run done on
all data, then the errors are calculated for the first time and the second run
is performed only on measurements with error lower than a certain threshold.

Empirically obtained values are \SI{10}{\minute} for the window width and
\SI{150}{\meter} for outlier threshold.

One might object, that this method of estimating receiver clock offset will
also include other effects from different sources than receiver clock,
for example atmospheric delays (imagine the user standing in a ball of material
that slows down propagation of radio signals), or signal processing delays
in the receiver.
This is true, but as far as localization is concerned, these effect would
be indistinguishable from receiver clock inaccuracies and will be
removed also during localization in a similar way.

\subsection{Applied corrections}
The web site \cite{sam-www} was very useful when implementing corrections for
pseudorange measurements.

\subsubsection{Ionospheric Corrections}

\subsubsection{Tropospheric Corrections}
\begin{itemize}
\item Ionospheric correction taken from SiRF. Where does it come from? SBAS?
    Estimated values transmitted with the navigation data?
\item Hopfield's tropospheric error model, implementation based on \cite{sam-www}.
\end{itemize}

\subsection{Position Error Model}
\Cref{fig:impl-error-histogam} shows the histogram of the corrected pseudorange
errors.
\begin{itemize}
\item Statistical testing for being gaussian\ldots
\item Modelling each satellite separately, based on previous error?
      Estimating residual errors per satellite?
\item Error based on signal strength?
\end{itemize}

\subsection{Velocity Error Model}
\Cref{fig:impl-error-histogam} shows the histogram of the corrected pseudorange
errors.
\begin{itemize}
\item Statistical testing for being gaussian\ldots
\item \url{http://www.gpspassion.com/forumsen/topic.asp?TOPIC_ID=7685#70279}
\end{itemize}

\begin{figure}[tp]
	\centering
	\missingfigure{Histogram of pseudorange errors}
	\caption{Histogram of pseudorange errors}
	\label{fig:impl-error-histogam}
\end{figure}

\section{Data From KarlÃ­k}
\begin{itemize}
\item Very briefly, parsing log formats from karlik
\item Which sensors we end up using
\end{itemize}

\section{Monte Carlo Localization}
\begin{itemize}
\item Used only for performance comparisons
\item Basic version of the algorithm
\end{itemize}
